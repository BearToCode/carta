import{t as z,h as N,a as q}from"../chunks/BPY3BYQk.js";import{p as Q,s as t,f as V,a as X,$ as Z,b as $}from"../chunks/CQjQfKBs.js";import{a as r,t as d}from"../chunks/CCNVrShP.js";import{C as a}from"../chunks/B5vJv_-j.js";var ee=z('<meta name="description" content="Extension API for Carta.">'),oe=z(`<span class="section">API</span> <h1 class="title">Extension</h1> <h2 id="plugin-properties"><code>Plugin</code> properties</h2> <p>You can easily extend Carta by creating custom plugins.</p> <!> <p>Here are all the <code>Plugin</code> properties:</p> <h3 id="transformers"><code>transformers</code></h3> <p>Type: <code>UnifiedTransformer</code></p> <p>Remark or Rehype transformers.</p> <!> <h4 id="transformer-execution"><code>UnifiedTransformer.execution</code></h4> Type:<code>'sync' | 'async'</code> <p>If you specify async, this transformer won’t be available for SSR.</p> <h4 id="transformer-type"><code>UnifiedTransformer.type</code></h4> Type:<code>'remark' | 'rehype'</code> <p>This determines at which step the transformer will operate, whether on Remark, on a Markdown-based
	syntax tree, or Rehype, on a HTML-based one.</p> <h4 id="transformer-transform"><code>UnifiedTransformer.transform</code></h4> <p>Type: <code>(&#123;(processor, carta)&#125;) => void</code></p> <p>The actual processor, can be async if the execution is specified as such.</p> <h3 id="shortcuts"><code>shortcuts</code></h3> Type:<code>KeyboardShortcut[]</code> <p>Additional keyboards shortcut. For example:</p> <!> <h4 id="shortcut-id"><code>KeyboardShortcut.id</code></h4> <p>Type: <code>string</code></p> <p>Id of the shortcut.</p> <h4 id="shortcut-combination"><code>KeyboardShortcut.combination</code></h4> <p>Type: <code>Set&lt;string&gt;</code></p> <p>Set of keys, corresponding to the <code>e.key</code> of <code>KeyboardEvents</code>, but
	lowercase.</p> <h4 id="shortcut-action"><code>KeyboardShortcut.action</code></h4> <p>Type: <code>(input: InputEnhancer) => void</code></p> <p>Shortcut callback function.</p> <h4 id="shortcut-prevent-save"><code>KeyboardShortcut.preventSave</code></h4> <p>Prevent saving the current state in history.</p> <h3 id="icons"><code>icons</code></h3> <p>Type: <code>Icon[]</code></p> <p>Additional toolbar icons. For example:</p> <!> <h4 id="icon-id"><code>Icon.id</code></h4> <p>Type: <code>string</code></p> <p>Id of the icon.</p> <h4 id="icon-action"><code>Icon.action</code></h4> <p>Type: <code>(input: InputEnhancer) => void</code></p> <p>Click callback.</p> <h4 id="icon-component"><code>Icon.component</code></h4> <p>Type: <code>ComponentType</code> (SvelteComponent)</p> <p>The Icon as a Svelte component.</p> <h3 id="prefixes"><code>prefixes</code></h3> <p>Type: <code>Prefix[]</code></p> <p>Text prefixes, default ones include the <code>-</code> for bulleted lists, <code>1.</code> for
	numbered lists, <code>- [ ]</code> for task lists.</p> <!> <h4 id="prefix-id"><code>Prefix.id</code></h4> <p>Type: <code>string</code></p> <p>Id of the prefix.</p> <h4 id="prefix-match"><code>Prefix.match</code></h4> <p>Type: <code>(line: string) => string | undefined</code></p> <p>Function that returns the prefix, if it is present.</p> <h4 id="prefix-maker"><code>Prefix.maker</code></h4> <p>Type: <code>(previousMatch: string, previousLine: string) => string</code></p> <p>Function that returns the prefix for the new line. <br> Example:</p> <!> <h3 id="tabOuts"><code>tabOuts</code></h3> <p>“Tab-outs” allow users to use the <code>tab</code> key to skip certain pieces of text. For
	example, after using the bold shortcut and having typed the text, you can press <code>tab</code> to skip the ending <code>**</code>.</p> <!> <h4 id="tabOut-id"><code>TabOut.id</code></h4> <p>Type: <code>string</code></p> <p>Id of the tab-out.</p> <h4 id="tabOut-delimiter"><code>TabOut.delimiter</code></h4> <p>Type: <code>string | readonly string[]</code></p> <p>Text(s) to check for. If one of them is found after the textarea <code>selectionEnd</code>,
	pressing tab will place the cursor after that.</p> <h3 id="listeners"><code>listeners</code></h3> <p>Type: <code>Listener[]</code></p> <p>Textarea event listeners. Has an additional <code>carta-render</code> and <code>carta-render-ssr</code> events keys.</p> <!> <h3 id="components"><code>components</code></h3> <p>Type: <code>ExtensionComponent[]</code></p> <p>Additional components to be added to the editor or viewer.</p> <h3 id="extension-component"><code>ExtensionComponent&lt;T&gt;.component</code></h3> <p>Type: <code>typeof SvelteComponentTyped&lt;T & &#123; carta: Carta &#125;&gt;</code></p> <p>Svelte components that exports <code>carta: Carta</code> and all the other properties specified as
	the generic parameter and in <code>props</code>.</p> <h3 id="extension-props"><code>ExtensionComponent&lt;T&gt;.props</code></h3> <p>Type: <code>T</code></p> <p>Properties that will be handed to the component.</p> <h3 id="extension-parent"><code>ExtensionComponent&lt;T&gt;.parent</code></h3> <p>Type: <code>MaybeArray&lt;'editor' | 'input' | 'renderer' | 'preview'&gt;</code></p> <p>Where the element will be placed.</p> <h3 id="grammar-rules"><code>grammarRules</code></h3> <p>Type: <code>GrammarRule[]</code></p> <p>Custom Markdown TextMate grammar rules for Shiki. They will be injected into the language.</p> <h3 id="highlight-rules"><code>highlightRules</code></h3> <p>Type: <code>HighlightingRule[]</code></p> <p>Custom highlighting rules for ShiKi. They will be injected into the selected theme.</p> <h3 id="on-load"><code>onLoad</code></h3> <p>Type: <code>(data: &#123; carta: Carta; highlight: HighlightFunctions &#125;) => void</code></p> <p>Use this callback to execute code when one Carta instance loads the extension.</p>`,1);function ae(D,c){Q(c,!0);var n=oe();N(o=>{var e=ee();Z.title="Extension - Carta",q(o,e)});var i=t(V(n),4);r(i,o=>{var e;return(e=d)==null?void 0:e(o)});var p=t(i,4);a(p,{get code(){return c.data.codeBlocks.extension}});var s=t(p,4);r(s,o=>{var e;return(e=d)==null?void 0:e(o)});var h=t(s,6);a(h,{get code(){return c.data.codeBlocks.transformer}});var l=t(h,2);r(l,o=>{var e;return(e=d)==null?void 0:e(o)});var u=t(l,6);r(u,o=>{var e;return(e=d)==null?void 0:e(o)});var m=t(u,6);r(m,o=>{var e;return(e=d)==null?void 0:e(o)});var f=t(m,6);r(f,o=>{var e;return(e=d)==null?void 0:e(o)});var v=t(f,6);a(v,{get code(){return c.data.codeBlocks.shortcut}});var y=t(v,2);r(y,o=>{var e;return(e=d)==null?void 0:e(o)});var g=t(y,6);r(g,o=>{var e;return(e=d)==null?void 0:e(o)});var T=t(g,6);r(T,o=>{var e;return(e=d)==null?void 0:e(o)});var x=t(T,6);r(x,o=>{var e;return(e=d)==null?void 0:e(o)});var b=t(x,4);r(b,o=>{var e;return(e=d)==null?void 0:e(o)});var _=t(b,6);a(_,{get code(){return c.data.codeBlocks.icon}});var k=t(_,2);r(k,o=>{var e;return(e=d)==null?void 0:e(o)});var C=t(k,6);r(C,o=>{var e;return(e=d)==null?void 0:e(o)});var w=t(C,6);r(w,o=>{var e;return(e=d)==null?void 0:e(o)});var S=t(w,6);r(S,o=>{var e;return(e=d)==null?void 0:e(o)});var I=t(S,6);a(I,{get code(){return c.data.codeBlocks.prefix}});var E=t(I,2);r(E,o=>{var e;return(e=d)==null?void 0:e(o)});var P=t(E,6);r(P,o=>{var e;return(e=d)==null?void 0:e(o)});var R=t(P,6);r(R,o=>{var e;return(e=d)==null?void 0:e(o)});var B=t(R,6);a(B,{get code(){return c.data.codeBlocks.prefixMaker}});var K=t(B,2);r(K,o=>{var e;return(e=d)==null?void 0:e(o)});var M=t(K,4);a(M,{get code(){return c.data.codeBlocks.tabOut}});var O=t(M,2);r(O,o=>{var e;return(e=d)==null?void 0:e(o)});var A=t(O,6);r(A,o=>{var e;return(e=d)==null?void 0:e(o)});var F=t(A,6);r(F,o=>{var e;return(e=d)==null?void 0:e(o)});var H=t(F,6);a(H,{get code(){return c.data.codeBlocks.listener}});var U=t(H,2);r(U,o=>{var e;return(e=d)==null?void 0:e(o)});var L=t(U,6);r(L,o=>{var e;return(e=d)==null?void 0:e(o)});var j=t(L,6);r(j,o=>{var e;return(e=d)==null?void 0:e(o)});var G=t(j,6);r(G,o=>{var e;return(e=d)==null?void 0:e(o)});var W=t(G,6);r(W,o=>{var e;return(e=d)==null?void 0:e(o)});var Y=t(W,6);r(Y,o=>{var e;return(e=d)==null?void 0:e(o)});var J=t(Y,6);r(J,o=>{var e;return(e=d)==null?void 0:e(o)}),$(4),q(D,n),X()}export{ae as component};
